# 案例分析
## 系统规划
### 可行性分析
- 经济可行性：投资/成本收益分析，主要评估项目的建设成本、运行成本和项目建成之后可能的经济收益
- 技术可行性：技术风险分析，评估信息系统需要实现的功能和性能，以及技术能力约束
- 法律可行性：社会可行性，从政策、法律、道德、制度等社会因素评估项目的现实性
- 运营可行性：评估项目实施后的运营效率和可维护性
- 时间可行性：评估项目是否能在预定的时间内完成
- 用户使用可行性：执行可行性，从使用该系统的用户角度评估系统的可行性，包括行政管理和工作制度、使用人员的培训等
### 成本效益计算
- 净现值 = 收入 * 折现系数 - 成本 * 折现系数
- 净现值率 = 净现值 / (成本 * 折现系数)
## 需求工程
### 需求获取
#### 问卷调查法
- 定义：通过设计问卷，**快速**收集**大规模用户群体**的**基本需求**
- 优点：
  - 能在短时间内从大范围群体中收集数据，效率高
  - 成本低，结果易于统计分析
#### 用户访谈法
- 定义：通过与用户**一对一**面对面或远程交流，**深入了解**其需求和问题
- 优点：
  - 灵活性强，能获取详细信息
  - 适用于复杂或关键用户需求的挖掘
#### 现场观察法
- 定义：直接观察**用户实际工作场景**（已有系统）的行为、反应和问题，可获得**第一手**真实资料
- 优点：
  - 获取真实、客观的需求信息
  - 有助于发现用户未明确表达但实际存在的需求
#### 采样
- 定义：从**数据量较大**的总体中选取**有代表性的样本**进行分析，以推断整体需求
- 采样计算：样本数量 = 0.25 * (可信度因子 / 可接受误差)2
- 优点：
  - 利用统计方法，减少数据收集偏差
  - 提高数据收集效率，降低成本
#### 联合需求计划JRP
- 定义：通过**高度组织的群体会议**来分析企业内的问题并获取需求的过程，由部门经理、会议主持人、用户、IT人员等共同组成**专题讨论组**来分析问题并定义系统需求
- 优点：
  - 发挥用户和管理人员参与系统开发的积极性，提高开发效率
  - 降低系统需求获取的时间，加速系统的开发周期
  - 通过原型对系统需求进行确认，具有原型化开发方法的优点
#### 情景串联板
- 定义：通过一系列**图片或图示**，展示用户与系统交互的典型场景，帮助识别需求
- 优点：
  - 直观、生动，便于用户理解和反馈
  - 促进团队成员之间的沟通和理解
## 系统分析与设计
### 面向对象设计
#### 设计类
- 实体类：映射需求中的实体对象，保存需要持久化存储的信息，如用户、商品
- 控制类：用于控制用例工作的类，对用例的控制行为继续建模，如结算、备货
- 边界类：封装在用例内外流动的信息或数据流，如浏览器、购物车
### 微服务
内容：资源、对资源的操作的一组API集合
优势：
- 将巨大的单体式应用分解成多个服务方法解决了复杂性问题，同时保持总体功能不变
- 让每个服务能够独立开发，开发者能够自由选择技术，提供API
- 每个服务器独立部署，加快部署速度
- 每个服务器支持独立扩展，根据服务器的规模来部署满足需求的规模
挑战：
- 并非所有系统都能转成微服务，如数据库的底层操作不推荐服务化
- 部署较以往架构更加复杂，每个服务器需要单独部署
- 由于微服务注重独立性，互相通信只能通过标准接口，可能产生延迟或调用异常
- 数据一致性问题，作为分布式部署的微服务，在保持数据一致性方面比传统模式更加困难
### 设计模式
- 创建型：主要用于创建对象，为设计类实例化新对象提供指南
- 结构型：主要用于处理类或对象的组合，对类如何设计以形成更大的结构提供指南
- 行为型：主要描述类或对象的交互以及职责的分配，对类之间交互以及分配责任的方式提供指南
#### 创建型
- 工厂：定义一个创建对象的接口，由子类决定需要实例化哪一个类
- 抽象工厂；提供一个接口，可以创建一系列相关的对象，无需指定具体的类
- 单例：保证一个类只有一个实例，并提供一个访问它的全局访问点
- 构造器：将复杂类的表示和构造分离，使得相同的构建过程能够得出不同的表示
- 原型：用原型实例指定创建对象的类型，通过拷贝这个原型来创建新对象
#### 结构型
- 外观Decorator：定义一个高层接口，为子系统中的一组接口提供一个一致的外观
- 享元Flyweight：提供支持大量细颗粒度对象共享的方法
- 代理Proxy：为其他对象提供一种代理以控制这个对象的访问
- 组合：将对象组成树型结构以表示整体与部分的层次关系
#### 行为型
- 解释器Interpreter：给定一种语言，定义文法表示，并定义一个解释器，用来根据文法表示来解释语言中的句子（自定义试卷以及试卷对应的评分标准）
- 中介Mediator：用一个中介对象来封装一系列的对象交互（各个构建不允许直接调用）
- 访问者Visitor：数据与操作分离
- 状态State：允许一个对象在其内部状态改变时，改变它的行为（会员升级后享有更多的服务）
- 观察者Observe：定义对象间的一对多的依赖关系，当对象发生变化时，所有依赖于它的对象都能得到通知并自动更新
## 建模图
### 常见图之间的对比
#### 活动图与状态图
- 活动图用于表示**某一用例**的具体动作，状态图用于描述**某个对象**的状态转化
- 活动图涉及多个对象，状态图针对单一对象
#### 互动图与流程图
### 活动图
- 着重描述系统的行为，描述的是对象活动的顺序关系所遵循的规则
- 可以表示并发活动的场景
- 面向对象
### 流程图
- 着重描述处理过程，主要的控制结构是顺序、分支和循环，各个处理过程之间有严格的顺序和时间关系
- 只能表示非并发活动场景
- 面向过程
### 状态图
- 主要描述一个对象在其生命周期内的动态行为
- 包含一个对象所经历的状态序列，引起状态转换的事件，以及因状态转移而伴随的动作
- 组成元素：状态（圆角矩形）、初状和终态（实心圆）、转移（两个状态之间的关系）、动作
## 数据库
### 问题
#### 不满足第三范式
- 问题：会产生函数的传递依赖，造成数据冗余和修改异常
  - 数据冗余是指属性名会被存储多次
  - 修改异常是值修改某个属性，需要修改该属性所有对应的元组属性
- 解决办法：使用触发器在修改时，检查并更新数据的方式来解决数据不一致的问题
#### 数据库并发问题
- 丢失修改：A和B读入同一数据并修改，B的提交结果破坏A的结果，导致A的修改被丢弃
- 读脏数据：将A修改的数据写入磁盘，B读取统一数据，但是A撤销，导致B读取的数据是无效数据
- 不可重复读：A读取数据后，B修改了该数据，但是A使用的还是之前的数据，产生了数据不一致性
- 解决办法：读写锁机制
- 缺点：虽然封锁的方法可以有效防止数据的不一致性，但也会产生死锁问题
### 数据库设计
- 概念设计：在需求分析阶段产生的需求说明书基础上，按照特定的方法将他们抽象为数据模型(概念模型)，E-R图
- 逻辑设计：将概念模型转化为逻辑模型，再对逻辑模型进行优化
- 物理设计：对给定的逻辑模型选取一个最适合应用环境的物理结构，主要是指数据库在物理设备上的存储结构和存取结构

### 反规范化设计
- 增加冗余类：在多个表中具有相同的列，在查询时避免连接操作
- 增加派生类：增加的列可以通过表中其他数据计算产生，减少查询时的计算量，加快查询速度
- 重新组表：如果许多用户需要查看两个表连接出来的结果数据，将两个表重新组成一个表，减少连接
- 表分割
  - 水平分割：根据某些条件将数据放到两个或多个独立的表中，按照记录进行分割
    - 优点：降低查询时需要读的数据和索引的页数，同时降低查询的层数，加快了查询的速度
    - 适用场景：表的数据量大、表中的数据具有独立性
  - 垂直分割：把主码和一些列放在一个表中，把主码和另外的列放在另外的表中
    - 优点：行数据变小，从而使一个数据块可以存储更多的数据、达到最大化利用Cache的目的

### 物理数据分区
- 水平分区
  - 范围分区
    - 优点：将表存储在多个表空间中，各分区维护各自的本地索引；可对单个表进行备份、归档，利于维护；实现容易，方便对表的分区进行添加、删除、拆分和合并操作
    - 缺点：数据分布不均匀
  - 哈希分区
  - 列表分区
- 垂直分区
## 项目管理
### 进度管理
#### 进度时间计算
考虑到任务之间的并行关系，工作量计算：人天
#### 进度调整
- 关键活动调整：任意活动时间的调整都会对整个项目的工期产生影响
- 非关键活动调整：必要时可以对该活动做适当调整，但不能超出总时差，且每次调整均需进行参数计算，以观察产生的影响
- 增减工作项：增加工作项，只对原遗漏或不具体的逻辑关系进行补充；减少工作项，只对提前完成或不应设置的的工作项进行消除
- 资源调整：若资源供应发生异常，进行资源调整
